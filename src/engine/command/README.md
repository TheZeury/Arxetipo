# Arxetipo Command Language

## Overview

Arxetipo Command Language is a simple scripting language for Arxetipo Engine. It can serve several purposes, such as:

1. In game command support for players.
2. Hot-loading temporary logics from servers without updating the game.
3. Writing some quick scripts for testing during development.

It's designed to be dynamic, concise and "just enough" to use. It's not designed to be a full featured high performance programming language. To achieve high performance and functionality, developers still need to write real codes in C++.

A major philosiphy of it's design is to not reserve any keywords, which may make it's syntax a little bit confusing at first.

## How to excute

To have a quick start, there's a completed CLI analyzer : src/lab_game/CommandTest.cpp. Compile it and run with one argument which is the path to a script file, or no argument to run in interactive mode.

To integrate the analyzer into your program, options are:

### Option 1. Using provided runtime

Simply provide where the code is read from and where the output is written to (and optionally where the error is printed to) to the runtime and you are good to go.

`arx::CommandRuntime` provides some predefined identifiers like `print` and `exit` which can be used in command.

```cpp
#include "../engine/command/command.hpp"

auto main() -> int {
    arx::CommandRuntime runtime{ std::cin, std::cout };
    runtime.run();
}
```

### Option 2. Manually

Chain `kernel`, `parser`, and `lexer` together, pass the command to the lexer using `<<` operator.

Tokens generated by the lexer will be passed to the parser, and the parser will generate AST which will be executed by the kernel.

```cpp
#include "../engine/command/command.hpp"

auto main() -> int {
    arx::CommandKernel kernel;
    arx::CommandParser parser{ kernel };
    arx::CommandLexer lexer{ parser };

    while (true) {
        try {
            std::string line;
            std::getline(std::cin, line);
            lexer << line;
        }
        catch (const arx::CommandError& e) {
            std::cerr << e.what() << std::endl;
        }
    }
}
```

There's no ostream needed because this is not a kernel feature, but more an implementation. You can implement your own `print` method like this:

```cpp
kernel.add_method("print", [&](const std::vector<CommandValue>& arguments, CommandValue& result) {
    for (const auto& argument : arguments) {
        std::cout << argument.to_string() << std::endl;
    }
    result = CommandValue{ CommandValue::Type::Empty, std::monostate{ } };
}, true);
```

It is also possible to pass AST to the kernel directly without a parser, or pass tokens to the parser directly without a lexer. But most of the time you don't need to do that.

```cpp
using TokenType = arx::CommandToken::Type;

std::vector<arx::CommandToken> tokens {
    { TokenType::Name, "print" },
    { TokenType::Separator, "(" },
    { TokenType::Number, "5" },
    { TokenType::Operator, "+" },
    { TokenType::Number, "10" },
    { TokenType::Separator, ")" },
    { TokenType::Separator, ";" },
};

for (const auto& token : tokens) {
    parser << token;
}

// Output: 15

auto twenty = arx::CommandASTExpressionNode::make_number(20.f);
auto three = arx::CommandASTExpressionNode::make_number(3.f);
auto multiply = arx::CommandASTExpressionNode::make_operation(arx::CommandASTOperationNode::Type::Multiply, { });
multiply.operations.push_back(std::move(twenty));
multiply.operations.push_back(std::move(three));
auto print = arx::CommandExpressionNode::make_method("print", { });
print.arguments.push_back(std::move(multiply));
auto statement = arx::CommandASTStatementNode::make_expression(std::move(print));

kernel << statement;

// Output: 60
```

A practical usage of the full control is to get AST from the parser for other purposes.

You can pass your interpreter to the parser as long as the type implemented `operator<<(const CommandASTStatementNode&)`:

```cpp
struct MyInterpreter {
    auto operator<<(const arx::CommandASTStatementNode& statement) -> MyInterpreter& {
        // ...
    }
};

MyInterpreter interpreter;
arx::CommandParser parser{ interpreter };
arx::CommandLexer lexer{ parser };

// ...
```

In fact there is a provided interpreter alternative called `arx::CommandFormatter` which prints formatted codes based on the AST:

```cpp
arx::CommandFormatter formatter{ output };
arx::CommandParser parser{ formatter };
arx::CommandLexer lexer{ parser };

auto line = "a=x     +30 /{<> * 3;}(5);print(a);";
lexer << line;

// Output: 
// a = x + 30 / {
//     < > * 3;
// }(5);
```

## Syntax

### Statements

#### Assignment

`[identifier] = [expression];`

```
a = 5;
b = a;
c = a + b + 5;
myprint = print;
d = ();
```

#### Single Expression

`[expression];`

```
a;
print(a, 20);
exit();
```

#### Fetch Argument

`>[identifier];`

`>>>>>>[identifier]`

`[identifier] = >;` This is acutally a assignment but has the same effect.

```
>a;
b = >;
>>c; // c fetches an argument of the outer method.
```

#### Return

`<[expression]`

```
<a;
< a + 5;
<; // Implicitly return ().
<(); // Explicitly return ().
<<; // Double return. Return two scopes with value ().
<<<<< 20; // Return five methods with the value 20.
```

#### Delete

`#[identifier]`

```
#a;
#myprint;
```

#### Protect

```
a = 5;
a = 10; // Reassign is ok without protection.
[a]; // Protect a.
a = 20; // Error. Cannot be reassigned once it's protected.
#a; // Error. Cannot be deleted once it's protected.

{
    a = 5;
    {
        [a];
        a = 10; // Error. Cannot be reassigned once it's protected.
        {
            a = 15; // Error. a is protected in the outer scope.
        }();
    }();
    a = 20; // Ok. Protection will be removed after the scope.
}();
```

Wait for the protection going out of scope is the only way to remove a protection.

So don't protect identifiers in the global scope unless you really know what you are doing.

Some application defined identifiers are protected by default like `print` or `exit` in the global scope. Those identifier are impossible to be reassigned or deleted in command. But the application can do anything through command runtime :).

### Expressions

#### Number

Stored in 32-bit float.

```
3;
50;
-5;
3.14;
2.718281828459045;
```

#### Identifier

```
a;
b;
print;
exit;
```

#### Operation

```
a + b;
a + b * (c - d);
() + 20; // 20
() - 20; // -20
5 * (); // ()
() + (); // ()
```

Empty operation rules(`[expression]` can also be `()`):

`() + [expression] = [expression]`

`[expression] + () = [expression]`

`() - [expression] = -[expression]`

`[expression - ()] = [expression]`

`() * [expression] = ()`

`[expression] * () = ()`

`() / [expression] = ()`

`[expression] / () = ()`

And any undefined operation will return `()`:

`[method] + 5 = ()`

`[method] * [method] = ()`

`-[method] = ()`


#### Method Call

A method is a **value** which can be assigned to a identifier.

```
print(a, b, c); // Return value: ()
a = sin(3); // a = 0.1411200080598672
mymethod = sin; // mymethod is now a alias method of sin.
b = mymethod(6.28);
```

#### Argument

In a method call, each time a `>` appears, it will have the value of the next argument.

```
>; // By doing this, a argument is ignored;
>(); // If a argument is a method, you can do this.
a = >; // Already mentioned in the assignment section.
```

#### Method Body

A method body returns a **method** which is a value.
A method body itself is **not** excuted, a method call is excuted.

```
add = { // Although assign it to a identifier is more common.
    >a;
    >b;
    < a + b;
};
print(add(3, 5));

{ < > + >; }(2, 3); // return 5.
// Since a method body returns a method, it can be called directly if you would like to.
```

#### Condition

`[expression] ? [expression]`

`[expression] ? [expression] : [expression]`

```
b = a ? a + 1 : 0;
```

We can combine immediate method call with condition to achieve `if else` effect:

```
a ? {
    print(a);
}();

a ? {
    print(a);
}() 
: {
    print(0);
}();

a ? {
    print(a);
}() 
: b ? {
    print(0);
}() 
: {
    print(1);
}();
```

Be careful that the parentheses following a method body is necessary, otherwise it will return a method as a value, and codes in the method body won't be excuted:

```
a = 5;

m = a ? {
    print(a);
} : {
    print(0);
}; // Nothing printed, m is assigned with a method.

m(); // 5 printed.
```

#### Self Call

`$([arguments])`

`$` means the method itself. By calling `$` at the end of a method body, we can achieve a loop.

```
a = 0;
{
    print(a);
    a = a + 1;
    10 - a ? $();
}();
// 0 1 2 3 4 5 6 7 8 9
```

### Examples

#### Fibonacci

```
fib = {
    >n;
    < n ? $(n - 1) + ( n - 1 ? $(n - 2) : 1 ) : 0;
};

print(fib(10)); // 55
```

```
fib = {
    >n;
    < n ? {
        >i; >a; >b;
        < n - i ? $(i + 1, b, a + b) : a + b;
    }(1, 1, 0) : 0;
};

print(fib(12)); // 144
```

#### Euclid's algorithm

```
gcd = {
    >a;
    >b;
    < b ? $(b, a % b) : a;
};

print(gcd(10, 15)); // 5
```

#### Factorial

```
fact = {
    >n;
    < n ? n * $(n - 1) : 1;
};
```